package com.app.ticketmelon.dev02.tmelonprogress;

import android.graphics.Paint;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import java.util.Stack;
/**
 * Created by dev02 on 5/22/2017 AD.
 */

/**
 * Created by pag on 5/22/17.
 * Copyright Â© 2017 CompanyName. All rights reserved.
 *
 * This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
 * http://www.paintcodeapp.com
 *
 * @author pag
 */


    public class Progress {



    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // In Trial version of PaintCode, the code generation is limited to 3 canvases.

    // Canvas Drawings
    // Tab

    private static class CacheForCanvas1 {
        private static Paint paint = new Paint();
        private static RectF originalFrame = new RectF(0f, 0f, 130f, 130f);
        private static RectF resizedFrame = new RectF();
        private static RectF bezierRect = new RectF();
        private static Path bezierPath = new Path();
        private static RectF bezier3Rect = new RectF();
        private static Path bezier3Path = new Path();
    }

    public static void drawCanvas1(Canvas canvas, float center, float rotation) {
        Progress.drawCanvas1(canvas, new RectF(0f, 0f, 130f, 130f), ResizingBehavior.AspectFit, center, rotation);
    }

    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing, float center, float rotation) {
        // General Declarations
        Stack<Matrix> currentTransformation = new Stack<Matrix>();
        currentTransformation.push(new Matrix());
        Paint paint = CacheForCanvas1.paint;

        // Local Colors
        int color4 = Color.argb(97, 146, 146, 146);
        int color5 = Color.argb(255, 92, 201, 238);

        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForCanvas1.resizedFrame;
        Progress.resizingBehaviorApply(resizing, CacheForCanvas1.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 130f, resizedFrame.height() / 130f);

        // Group
        {
            // Bezier
            RectF bezierRect = CacheForCanvas1.bezierRect;
            bezierRect.set(25f, 25f, 102f, 102f);
            Path bezierPath = CacheForCanvas1.bezierPath;
            bezierPath.reset();
            bezierPath.moveTo(63.5f, 26f);
            bezierPath.cubicTo(52.48f, 26f, 42.57f, 30.75f, 35.71f, 38.33f);
            bezierPath.cubicTo(29.67f, 44.98f, 26f, 53.81f, 26f, 63.5f);
            bezierPath.cubicTo(26f, 84.21f, 42.79f, 101f, 63.5f, 101f);
            bezierPath.cubicTo(84.21f, 101f, 101f, 84.21f, 101f, 63.5f);
            bezierPath.cubicTo(101f, 42.79f, 84.21f, 26f, 63.5f, 26f);
            bezierPath.close();
            bezierPath.moveTo(102f, 63.5f);
            bezierPath.cubicTo(102f, 84.76f, 84.76f, 102f, 63.5f, 102f);
            bezierPath.cubicTo(42.24f, 102f, 25f, 84.76f, 25f, 63.5f);
            bezierPath.cubicTo(25f, 53.61f, 28.73f, 44.59f, 34.86f, 37.77f);
            bezierPath.cubicTo(41.91f, 29.93f, 52.13f, 25f, 63.5f, 25f);
            bezierPath.cubicTo(84.76f, 25f, 102f, 42.24f, 102f, 63.5f);
            bezierPath.close();

            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStyle(Paint.Style.FILL);
            paint.setColor(color4);
            canvas.drawPath(bezierPath, paint);

            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(center);
            paint.setStrokeMiter(10f);
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(Color.LTGRAY);
            canvas.drawPath(bezierPath, paint);
            canvas.restore();

            // Bezier 3
            canvas.save();
            canvas.translate(63.5f, 63.5f);
            currentTransformation.peek().postTranslate(63.5f, 63.5f);
            canvas.rotate(-rotation);
            currentTransformation.peek().postRotate(-rotation);
            RectF bezier3Rect = CacheForCanvas1.bezier3Rect;
            bezier3Rect.set(29.5f, 0f, 57.5f, 45.31f);
            Path bezier3Path = CacheForCanvas1.bezier3Path;
            bezier3Path.reset();
            bezier3Path.moveTo(35.4f, 45.31f);
            bezier3Path.cubicTo(34.4f, 44.04f, 32.26f, 41.29f, 29.5f, 37.76f);
            bezier3Path.cubicTo(40.71f, 28.99f, 47.92f, 15.34f, 47.92f, 0f);
            bezier3Path.lineTo(57.5f, 0f);
            bezier3Path.cubicTo(57.5f, 18.4f, 48.85f, 34.79f, 35.4f, 45.31f);
            bezier3Path.close();

            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStyle(Paint.Style.FILL);
            paint.setColor(color5);
            canvas.drawPath(bezier3Path, paint);
            canvas.restore();
        }

        canvas.restore();
    }


    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }

        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }

        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }

        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
                target.centerY() - newHeight / 2,
                target.centerX() + newWidth / 2,
                target.centerY() + newHeight / 2);
    }


}

